{"ast":null,"code":"var _classCallCheck = require(\"/Users/harry/Projects/portfolio/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/harry/Projects/portfolio/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Promise = require('bluebird');\n\nvar BaseApi =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function BaseApi(persistent) {\n    _classCallCheck(this, BaseApi);\n\n    this.persistent = persistent; // for MemoryStorage\n\n    this._lootBag = {}; // by default there is no general timeout for all keys\n\n    this._timeout = null;\n  } // general timeout: this applies to all keys put without a specific timeout.\n\n\n  _createClass(BaseApi, [{\n    key: \"get\",\n    // If key does not exist:\n    //   if 2nd arg is passed, i.e., default is defined, return default\n    //   if 2nd arg is not passed, return null\n    //\n    // Note: \"kt\" property is the key-based timeout (in seconds), optionally sent\n    // to put method.\n    value: function get(key) {\n      var _this = this;\n\n      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return new Promise(function (resolve) {\n        if (_this.persistent) {\n          // local storage\n          if (key in localStorage) {\n            var obj = JSON.parse(localStorage.getItem(key));\n\n            if (_this._timeout === null && obj.kt === null) {\n              resolve(obj.v);\n            } else {\n              if (_this._isCacheStale(obj)) {\n                _this.removeKey(key).then(function () {\n                  resolve(defaultValue);\n                });\n              } else {\n                resolve(obj.v);\n              }\n            }\n          } else {\n            resolve(defaultValue);\n          }\n        } else {\n          // in memory\n          if (key in _this._lootBag) {\n            if (_this._timeout === null && _this._lootBag.kt === null) {\n              resolve(_this._lootBag[key].v);\n            } else {\n              if (_this._isCacheStale(_this._lootBag[key])) {\n                _this.removeKey(key).then(function () {\n                  resolve(defaultValue);\n                });\n              } else {\n                resolve(_this._lootBag[key].v);\n              }\n            }\n          } else {\n            resolve(defaultValue);\n          }\n        }\n      });\n    } // keyTimeout is optional. If passed in, its value overrides general\n    // timeoutInSeconds setting.\n\n  }, {\n    key: \"put\",\n    value: function put(key, val) {\n      var _this2 = this;\n\n      var keyTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      return new Promise(function (resolve) {\n        var item = {\n          v: val,\n          t: _this2._getNow(),\n          kt: keyTimeout\n        };\n\n        if (_this2.persistent) {\n          localStorage.setItem(key, JSON.stringify(item));\n          resolve();\n        } else {\n          _this2._lootBag[key] = item;\n          resolve();\n        }\n      });\n    }\n  }, {\n    key: \"removeKey\",\n    value: function removeKey(key) {\n      var _this3 = this;\n\n      return new Promise(function (resolve) {\n        if (_this3.persistent) {\n          if (key in localStorage) {\n            localStorage.removeItem(key);\n          }\n        } else {\n          if (key in _this3._lootBag) {\n            delete _this3._lootBag[key];\n          }\n        }\n\n        resolve();\n      });\n    } // Garbage Collector: remove all keys that:\n    //\n    //   have either a global or key level timeout\n    //\n    //   AND\n    //\n    //   timeout has expired\n    //\n    // ttl-localstorage lazily removes keys if not explicitly removed via\n    // #removeKey; if a key is accessed either via #get or $keyExists, the key is\n    // removed if a timeout indicates it's expired. There is no automatic garbage\n    // collector always running to periodically clean things up.\n    //\n    // This method allows the developer to manually clean up all keys that have an\n    // expired timeout.\n\n  }, {\n    key: \"runGarbageCollector\",\n    value: function runGarbageCollector() {\n      var _this4 = this;\n\n      return new Promise(function (resolve) {\n        var garbageKeys = [];\n\n        if (_this4.persistent) {\n          var _arr = Object.keys(localStorage);\n\n          for (var _i = 0; _i < _arr.length; _i++) {\n            var key = _arr[_i];\n            var obj = JSON.parse(localStorage.getItem(key));\n\n            if (!(_this4._timeout === null && obj.kt === null)) {\n              if (_this4._isCacheStale(obj)) {\n                localStorage.removeItem(key);\n                garbageKeys.push(key);\n              }\n            }\n          }\n        } else {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = _this4._lootBag[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var _key = _step.value;\n\n              if (!(_this4._timeout === null && _this4._lootBag[_key].kt === null)) {\n                if (_this4._isCacheStale(_this4._lootBag[_key])) {\n                  delete _this4._lootBag[_key];\n                  garbageKeys.push(_key);\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n\n        resolve(garbageKeys);\n      });\n    } // If a TTL is set and the key has expired, its existence is set free. :)\n\n  }, {\n    key: \"keyExists\",\n    value: function keyExists(key) {\n      var _this5 = this;\n\n      return new Promise(function (resolve) {\n        if (_this5.persistent) {\n          // local storage\n          if (key in localStorage) {\n            var obj = JSON.parse(localStorage.getItem(key));\n\n            if (_this5._timeout === null && obj.kt === null) {\n              resolve(true);\n            } else {\n              if (_this5._isCacheStale(obj)) {\n                _this5.removeKey(key).then(function () {\n                  resolve(false);\n                });\n              } else {\n                resolve(true);\n              }\n            }\n          } else {\n            resolve(false);\n          }\n        } else {\n          // in memory\n          if (key in _this5._lootBag) {\n            if (_this5._timeout === null && _this5._lootBag.kt === null) {\n              resolve(true);\n            } else {\n              if (_this5._isCacheStale(_this5._lootBag[key])) {\n                resolve(false);\n\n                _this5.removeKey(key).then(function () {});\n              } else {\n                resolve(true);\n              }\n            }\n          } else {\n            resolve(false);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this6 = this;\n\n      return new Promise(function (resolve) {\n        if (_this6.persistent) {\n          localStorage.clear();\n          resolve();\n        } else {\n          _this6._lootBag = {};\n          resolve();\n        }\n      });\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      var _this7 = this;\n\n      return new Promise(function (resolve) {\n        if (_this7.persistent) {\n          resolve(Object.keys(localStorage));\n        } else {\n          resolve(Object.keys(_this7._lootBag));\n        }\n      });\n    }\n  }, {\n    key: \"isLocalStorageAvailable\",\n    value: function isLocalStorageAvailable() {\n      return new Promise(function (resolve) {\n        var key = new Date().getTime().toString();\n        var val = key;\n\n        try {\n          localStorage.setItem(key, val);\n          localStorage.removeItem(key);\n          resolve(true);\n        } catch (ex) {\n          resolve(false);\n        }\n      });\n    }\n  }, {\n    key: \"_getNow\",\n    value: function _getNow() {\n      return parseInt(Date.now() / 1000, 10);\n    } // This method is called only when at least one of the timeouts has been set.\n    // key timeout has priority. general this._timeout is used only if key\n    // timeout hasn't been set.\n\n  }, {\n    key: \"_isCacheStale\",\n    value: function _isCacheStale(obj) {\n      var timestamp = obj.t;\n      var timeout = obj.kt === null ? this._timeout : obj.kt;\n      return this._getNow() - timestamp > timeout;\n    }\n  }, {\n    key: \"timeoutInSeconds\",\n    set: function set(timeInSeconds) {\n      this._timeout = timeInSeconds;\n    },\n    get: function get() {\n      return this._timeout;\n    }\n  }]);\n\n  return BaseApi;\n}();\n\nmodule.exports = BaseApi;","map":null,"metadata":{},"sourceType":"script"}